Name,Description,Script
Hidden Blade,Get a Dagger for this turn and roll 3 low dice,giveequipment(~Dagger~); givedice([rand([1[;] 2[;] 3])[;] rand([1[;] 2[;] 3])[;] rand([1[;] 2[;] 3])]);
Sharpening,Increase damage by 3 this fight,sfx(~_metals~); inflictself(~mqsharpening~[;] 3);
Pocket Chisel,-1 to all dice[;] roll a 1 for each dice,var ones = []; var c = 0; for (mydice in self.dicepool) if (mydice.available()) {var newvalue = mydice.basevalue - 1; if (newvalue < 1) newvalue = 1; mydice.animatereroll(newvalue[;] self.screenposition()[;] c * 0.05); c++; ones.push(1);} givedice(ones);
Prediction,Dodge the next attack,sfx(~_dodge~); inflictself(DODGE);
Speculation,50% chance to dodge the next attack,sfx(~_dodge~); inflictself(~alternate_dodge~);
Luckier Roll,Roll an extra six,givedice(6);
Lucky Bomb,Do [sword]7 damage,attack(7); sfxdamage(7[;] target);
Rejuvenation,Heal [heal]6 health,attackself(-6); sfx(~_heal~);
Refinery,Upgrade something (once),var upgradeable = []; for (eq in self.equipment) if (!eq.originallyupgraded && !eq.upgraded && eq.name != ~Flamethrower~ && eq.skillcard == ~~ && eq.ready) upgradeable.push(eq); if (upgradeable.length > 0) {sfx(~upgradeequipment~); var myeq = rand(upgradeable); var oldx = myeq.x; var oldy = myeq.y; myeq.create(myeq.name[;] true); myeq.x = oldx; myeq.y = oldy; myeq.animate(~flashandshake~); myeq.ready = true; Gadget.changegadget(self[;] ~Refinery~[;] ~Broken Gadget~);}
Megaflick,Throw all dice[;] get new,var dicenum = 0; var newdice = []; for (mydice in self.dicepool) if (mydice.available()) {dicenum++; newdice.push(rand([1[;] 2[;] 3[;] 4[;] 5[;] 6]));} for (i in 0...dicenum) throwdice(self[;] target[;] i * 0.2); var actDelayedFunction = new motion.actuators.SimpleActuator(null[;] dicenum * 0.2[;] null); actDelayedFunction.onComplete(givedice[;] [newdice]); actDelayedFunction.move();
Revolver,[sword]6 dmg (even turns),if ((turn % 2) == 0) {attack(6); sfxdamage(6[;] target);} else target.textparticle(~No effect!~);
Mailbox,Get a random item,sfx(~_thinghappens~); giveequipment(rand([~Magic Axe~[;] ~Fortress~[;] ~Lightning Pistol~[;] ~Matchstick~[;] ~Nightstick~[;] ~Disduplicator~[;] ~Evening Charm~[;] ~Sonar~[;] ~Acupuncture~[;] ~Poison Edge~[;] ~Fake Call~[;] ~Blightning Rod~[;] ~Venom Extractor~[;] ~Assemble~[;] ~Keychain~]));
Recalculate,Set CPU counter to 0[;] destroy all dice,adjustrobotcounter(-self.roll_total); for (mydice in self.dicepool) if (mydice.available()) mydice.animate(~disappear~);
Sentry Gun (LV0),No effect,
Sentry Gun (LV1),Do [sword]3 damage,attack(3); sfxdamage(3[;] target);
Sentry Gun (LV2),Do [sword]6 damage,attack(6); sfxdamage(3[;] target);
Sentry Gun (LV3),[sword]6 dmg + [fire]2 burn,attack(6); sfxdamage(6[;] target); inflict(FIRE[;] 2); sfx(~_fire~[;] ~~[;] 0.2);
Dispenser (LV0),No effect,
Dispenser (LV1),Recover [heal]1 health,attackself(-1); sfx(~_heal~);
Dispenser (LV2),Recover [heal]2 health,attackself(-2); sfx(~_heal~);
Dispenser (LV3),Recover [heal]3 health,attackself(-3); sfx(~_heal~);
Teleporter (LV0),No effect,
Teleporter (LV1),Reduce by [reduce]1 (once),inflictself(REDUCE); sfx(~_shield~); Gadget.changegadget(self[;] ~Teleporter (LV1)~[;] ~Teleporter (LV0)~);
Teleporter (LV2),Dodge [dodge]1 (once),inflictself(DODGE); sfx(~_dodge~); Gadget.changegadget(self[;] ~Teleporter (LV2)~[;] ~Teleporter (LV0)~);
Teleporter (LV3),Get an extra turn (once),inflictself(EXTRATURN); sfx(~_recycle~); Gadget.changegadget(self[;] ~Teleporter (LV3)~[;] ~Teleporter (LV0)~);
Drill,Reactivate gadgets,Gadget.reactivate(self[;] ALL); sfx(~_recycle~);
Fair Trade,Swap one item,sfx(~_whoosh~); var myitem = rand(getequipmentlist(self)); var enemyitem = rand(getequipmentlist(target)); if (myitem != null && enemyitem != null) {var myitemactual = null; for (eq in self.equipment) if (eq.name + eq.namemodifier == myitem) myitemactual = eq; replacemewith(enemyitem[;] 1[;] myitemactual[;] self); removeequipment(enemyitem[;] target); giveenemyequipment(myitem[;] false[;] false);}
Make a Gadget,and disable 2 items,var possibleeq = []; if (self.equipment.length > 0) for (eq in self.equipment) if (eq.skillcard == ~~ && eq.ready) possibleeq.push(eq); if (possibleeq.length >= 2) {shuffle(possibleeq); var gadgeteq = [possibleeq.pop()[;] possibleeq.pop()]; sfx(~_metals~); sfx(~_thinghappens~); for (myeq in gadgeteq) {myeq.animation = []; myeq.animate(~curse~); myeq.animation[0].parameter[2] = ~[cog] Destroyed!~; myeq.ready = false;} var newgadget = rand([~Stardust~[;] ~Power Up~[;] ~Throw Dice~[;] ~Time Stop~[;] ~Blood Sip~[;] ~Infinity Mirror~[;] ~Megaflip~[;] ~Magic Six~[;] ~Bubble Gun~[;] ~Catapult~[;] ~Dramatic Pause~[;] ~Quick Thinking~[;] ~Random Roll~[;] ~Arctic Storm~[;] ~Pillow Fort~[;] ~Zap~[;] ~Ember~[;] ~Mumble~[;] ~Needle~[;] ~Efficiency~[;] ~Scream~[;] ~Harvest~[;] ~Overload~[;] ~Dial Up Sounds~[;] ~Magic Spanner~[;] ~Replicate~[;] ~Flash Freeze~[;] ~Refinery~[;] ~Mailbox~[;] ~Megaflick~[;] ~Ice Torch~[;] ~Lockdown~[;] ~Battery~]); Gadget.changegadget(self[;] Gadget.getcurrentgadget(self)[;] newgadget); Gadget.reactivate(self[;] newgadget);} Gadget.reactivate(self[;] ~Make a Gadget~);
Black Hole,-1 enemy dice,sfx(~_blind~); target.extradice--; if ((target.dice + target.extradice) < 1) target.extradice = 1 - target.dice;
Guarding Charm,Block [shield]8 damage,sfx(~_shield~); inflictself(SHIELD[;] 8);
Underflow,Receive a -1,givedice([-1]);
Battery,+3 to limit break,var addlimit = 3; if (self.limitvalue + addlimit > self.limitmax) {if (self.limitvalue < self.limitmax) addlimit = self.limitmax - self.limitvalue; else addlimit = 0;} self.limitvalue += addlimit; sfx(~_cure~);
Water Bucket,Extinguish dice,for (mydice in self.dicepool) {mydice.burn = false; if (mydice.overlayimage == ~fire~) {mydice.overlayimage = ~~; mydice.showoverlayimage = false;}}
Lockdown,Inflict [lock]1 lock,inflict(LOCK); sfx(~_lock~[;] ~~[;] 0.2);
Ice Torch,[fire]Burn and [ice]freeze,inflict(FIRE); inflict(ICE); sfx(~_fire~); sfx(~_ice~);
Unlimited,No effect,
Stargazing,Dodge [dodge]2 attacks,sfx(~_dodge~); inflictself(DODGE[;] 2);
mqtimerfix,Internal script for timer equipment,for (eq in self.equipment) if (eq.scriptonanyequipmentuse != null && eq.scriptonanyequipmentuse != ~~ && eq.scriptonanyequipmentuse.indexOf(~mqtimer_equipment_use_check~) == -1) {eq.scriptonanyequipmentuse = ~if (e.getvar(\~mqtimer_equipment_use_check\~) < self.equipmentused) {~ + eq.scriptonanyequipmentuse + ~} e.setvar(\~mqtimer_equipment_use_check\~[;] self.equipmentused);~;}
mqheliuminit,Internal script for Helium equipment,if (getstatusself(~mqhelium~) <= 0) {inflictself(~mqhelium~); sfx(~helium_fly~); if (self.equipment.length > 0) for (eq in self.equipment) eq.setvar(~mqhelium_speed~[;] 0); var actHelium = new motion.actuators.SimpleActuator(null[;] 0[;] null); actHelium.repeat(-1); var funcHelium = new hscript.Parser().parseString(~if (getstatusself(\~mqhelium\~) <= 0 # self.hp <= 0 # target.hp <= 0) actHelium._repeat = 0; if (self.equipment.length > 0) for (eq in self.equipment) if (eq.ready && eq.skillcard == \~\~ && (eq.getvar(\~mqhelium_affected\~) == 1 # eq.script.indexOf(\~/*mqhelium\~) != -1)) {var tags = eq.script.substr(eq.script.indexOf(\~/*mqhelium\~) + 10[;] eq.script.substr(eq.script.indexOf(\~/*mqhelium\~) + 10).indexOf(\~*/\~)).split(\~:\~); var helium_multiplier = 1 + (tags.indexOf(\~double\~) != -1 ? 0.5 : 0) - (tags.indexOf(\~half\~) != -1 ? 0.5 : 0) - getstatusself(\~mqheliumreduction\~) / 100; if (helium_multiplier < 0) helium_multiplier = 0; eq.y = eq.y - eq.getvar(\~mqhelium_speed\~) * helium_multiplier; eq.setvar(\~mqhelium_speed\~[;] eq.getvar(\~mqhelium_speed\~) + 1); if (eq.y <= -eq.height / 3 * 2) {sfx(\~helium_pop\~); eq.animate(\~curse\~); eq.ready = false; eq.animation[0].parameter[2] = \~[star] Pop!\~; eq.animation[0].command[5] = \~\~;}}~); var interp = new hscript.Interp(); interp.variables.set(~self~[;] self); interp.variables.set(~target~[;] target); interp.variables.set(~getstatusself~[;] getstatusself); interp.variables.set(~sfx~[;] sfx); interp.variables.set(~actHelium~[;] actHelium); interp.variables.set(~trace~[;] trace); actHelium.onRepeat(interp.execute[;] [funcHelium]); actHelium.move();}
mqgetequipmentlist,Internal script. Sets the user's mqallequipment to a list of all non-special equipment,self.setvar(~mqallequipment~[;] getequipmentlist());
mqgetloadedmods,Internal script. Sets the user's mqloadedmods to an array of some loaded mods,var loadedmods = []; if (getequipmentlist().indexOf(~Helium Balloon~) != -1) loadedmods.push(~morefluff~); self.setvar(~mqloadedmods~[;] loadedmods);
mqrepeatingjinx,Internal script that inflicts a jinx that repeats itself every few turns,var i = self.getvar(~mqrepeatingjinx_current_index~); var execscr = ~ self.setvar(\~mqrepeatingjinx_current_index\~[;] ~ + i + ~); new elements.Skill(\~mqrepeatingjinx\~).execute(self.getvar(\~mqrepeatingjinx_self_\~ + ~ + i + ~)[;] self.getvar(\~mqrepeatingjinx_target_\~ + ~ + i + ~));~; if (target != self.getvar(~mqrepeatingjinx_target_~ + i)) execscr = ~ target.setvar(\~mqrepeatingjinx_current_index\~[;] ~ + i + ~); new elements.Skill(\~mqrepeatingjinx\~).execute(target.getvar(\~mqrepeatingjinx_target_\~ + ~ + i + ~)[;] target.getvar(\~mqrepeatingjinx_self_\~ + ~ + i + ~));~; jinx(self.getvar(~mqrepeatingjinx_title_~ + i)[;] self.getvar(~mqrepeatingjinx_details_status_~ + i) + ~[;] then do it again in ~ + self.getvar(~mqrepeatingjinx_turns_~ + i) + ~ turn~ + (self.getvar(~mqrepeatingjinx_turns_~ + i) > 1 ? ~s~ : ~~)[;] self.getvar(~mqrepeatingjinx_details_~ + i)[;] self.getvar(~mqrepeatingjinx_script_~ + i) + execscr[;] self.getvar(~mqrepeatingjinx_target_~ + i)[;] self.getvar(~mqrepeatingjinx_self_~ + i)[;] self.getvar(~mqrepeatingjinx_turns_~ + i)[;] self.getvar(~mqrepeatingjinx_value_~ + i)); for (eq in self.equipment) eq.scriptaftercombat += ~ var vars = [\~current_index\~[;] \~next_index\~[;] \~title\~[;] \~details_status\~[;] \~details\~[;] \~script\~[;] \~target\~[;] \~self\~[;] \~turns\~[;] \~value\~]; for (_var in vars) self.setvar(\~mqrepeatingjinx_\~ + _var + \~_\~ + ~ + i + ~[;] 0);~;
mqelementalresistancefix,Internal script. Makes elemental strengths and weaknesses cancel each other out; applies strength/weakness display statuses and removes them; removes duplicate elemental resistance innates,var elements = [~fire~[;] ~ice~[;] ~shock~[;] ~poison~]; var remove_innates = []; for (element in elements) {if (self.innate.indexOf(~weak~ + element) != -1 && self.innate.indexOf(~strong~ + element) != -1) {self.innate.remove(~weak~ + element); removestatusself(~mqweakness~ + element); self.innate.remove(~strong~ + element); removestatusself(~mqstrength~ + element);} if (self.innate.indexOf(~strong~ + element) != -1 && getstatusself(~mqstrength~ + element) <= 0) inflictself(~mqstrength~ + element); if (self.innate.indexOf(~weak~ + element) != -1 && getstatusself(~mqweakness~ + element) <= 0) inflictself(~mqweakness~ + element); var strengths = 0; var weaknesses = 0; if (self.innate.length > 0) for (innate in self.innate) {if (innate == ~strong~ + element) {strengths++; if (strengths > 1) remove_innates.push(innate);} if (innate == ~weak~ + element) {weaknesses++; if (weaknesses > 1) remove_innates.push(innate);}}} if (remove_innates.length > 0) {for (innate in remove_innates) self.innate.remove(innate);}
mqelementalresistancefixboth,Internal script. Executes mqelementalresistancefix for self and target,new elements.Skill(~mqelementalresistancefix~).execute(self[;] self); new elements.Skill(~mqelementalresistancefix~).execute(target[;] target);
mqfinalroundinit,Internal script for Final Round,self.setvar(~finalround_progress~[;] 0); var enemies = [~Warrior~[;] ~Thief~[;] ~Robot ~[;] ~Inventor~[;] ~Witch~[;] ~Jester~]; enemies.remove(self.name == ~Robot~ ? self.name + ~ ~ : self.name); self.setvar(~finalround_enemies~[;] enemies); switchenemy(target[;] self.getvar(~finalround_enemies~)[self.getvar(~finalround_progress~)]); var actFinalRound = new motion.actuators.SimpleActuator(null[;] 0[;] null); actFinalRound.repeat(-1); inflictself(~mqtimeruntilendcombat~); var funcFinalRound = new hscript.Parser().parseString(~if (getstatusself(\~mqtimeruntilendcombat\~) <= 0 # self.hp <= 0 # target.hp <= 0) actFinalRound._repeat = 0; if (target.hp <= 1 && getstatus(SURVIVE) <= 0 && self.getvar(\~finalround_progress\~) < (self.getvar(\~finalround_enemies\~).length - 1)) {self.setvar(\~finalround_progress\~[;] self.getvar(\~finalround_progress\~) + 1); switchenemy(target[;] self.getvar(\~finalround_enemies\~)[self.getvar(\~finalround_progress\~)]); var actDelayedFunction = new motion.actuators.SimpleActuator(null[;] 0.2[;] null); var skill = new elements.Skill(\~Unlimited\~); skill.script = new elements.Fighter(self.getvar(\~finalround_enemies\~)[self.getvar(\~finalround_progress\~)]).scriptbeforecombat; actDelayedFunction.onComplete(skill.execute[;] [target[;] self]); actDelayedFunction.move(); var remove_status = []; if (target.status.length > 0) for (status in target.status) if (!status.jinx) remove_status.push(status); if (remove_status.length > 0) for (status in remove_status) removestatus(status.type[;] ALL); inflict(\~mqtimeruntilendcombat\~); target.hp = target.maxhp; target.extradice = 0; sfx(\~defeatmonster\~); attackself(-50); if (self.dicepool.length >= 0) {inflictself(EXTRATURN); self.endturnnow();} else {target.endturnnow();}} if (getstatus(SURVIVE) <= 0 && self.getvar(\~finalround_progress\~) < (self.getvar(\~finalround_enemies\~).length - 1)) {inflict(SURVIVE); inflict(\~mqfinalround\~);} if (getstatus(SURVIVE) <= 0) removestatus(\~mqfinalround\~); if (target.equipment.length > 0) for (eq in target.equipment) if (eq.name.indexOf(\~Contestant Card\~) != -1) eq.skillcard = \~contestantcard\~; target.graphic.set_scale(0.66);~); var interp = new hscript.Interp(); interp.variables.set(~self~[;] self); interp.variables.set(~target~[;] target); interp.variables.set(~getstatus~[;] getstatus); interp.variables.set(~getstatusself~[;] getstatusself); interp.variables.set(~inflict~[;] inflict); interp.variables.set(~inflictself~[;] inflictself); interp.variables.set(~switchenemy~[;] switchenemy); interp.variables.set(~sfx~[;] sfx); interp.variables.set(~attackself~[;] attackself); interp.variables.set(~removestatus~[;] removestatus); interp.variables.set(~SURVIVE~[;] SURVIVE); interp.variables.set(~EXTRATURN~[;] EXTRATURN); interp.variables.set(~ALL~[;] ALL); interp.variables.set(~actFinalRound~[;] actFinalRound); interp.execute(funcFinalRound); actFinalRound.onRepeat(interp.execute[;] [funcFinalRound]); actFinalRound.move(); target.setvar(~Rules~[;] self.getvar(~Rules~)); target.setvar(~mqcustomscript~[;] {file: ~mqenemylimitbreak~[;] variables: [{name: ~Rules~[;] value: self.getvar(~Rules~)}]}); new elements.Skill(~mqcustomscript~).execute(target[;] self); target.setvar(~Rules~[;] 0); self.setvar(~Rules~[;] 0);
mqrobotcalculate,Internal script for Enemy Robot calculate simulation,var rolled = rand([1[;] 2[;] 3[;] 4[;] 5[;] 6]); if (self.roll_total + rolled > self.roll_target && self.getvar(~mqrobotfakecpu_guaranteedjackpot~) == 1 && self.roll_jackpot <= 0) rolled = self.roll_target - self.roll_total; givedice(rolled); var mydice = self.dicepool[self.dicepool.length - 1]; var robotstatus = self.getvar(~mqrobotstatus~); if (robotstatus.length > 0) for (status in robotstatus) if (status.value > 0) {if (status.type == FIRE) {mydice.animate(~fire~); mydice.burn = true; status.value--;} if (status.type == ICE && !mydice.burn) {mydice.animate(~ice~); rolled = 1; status.value--;} if (status.type == LOCK) {mydice.animate(~lock~); status.value--;}} self.roll_totaldice++; if (self.equipment.length > 0) for (eq in self.equipment) if (eq.locked > 0 && !eq.unlockedthisturn) {eq.unlocked = self.roll_totaldice; eq.unlockflash = 1;} sfx(~jackpot_rolldice~); for (i in 0...rolled) sfx(~jackpot_increasecounter~[;] ~~[;] 0.05 * (i + 1)); self.roll_total += rolled; self.roll_realtotal = self.roll_total; if (self.roll_total > self.roll_target) self.roll_total = self.roll_target; if (self.roll_realtotal > self.roll_target && self.roll_jackpot <= 0) {roboterror(self); sfx(~roboterror~);} if (self.roll_realtotal == self.roll_target && self.roll_jackpot <= 0) {sfx(~jackpot_autoroll~); var e = self.getvar(~mqrobotcalculatecard~); e.availablethisturn = true; e.animate(~~); e.animation[e.animation.length - 1].addcommand(~textparticle~[;] ~[star] Jackpot!~[;] 16777215); e.animate(~flashandshake~); e.changecolour(~YELLOW~); self.roll_jackpot = 1; target.roll_jackpot = 1; var randjackpotskill = rand([1[;] 2[;] 3]); if (randjackpotskill == 1) {attack(5); sfxdamage(target[;] 5);} if (randjackpotskill == 2) {attackself(-3); sfx(~_heal~);} if (randjackpotskill == 3) {new elements.Skill(~mqrobotcalculate~).execute(self[;] target);} inflictself(~mqrobotjackpot~ + randjackpotskill);} self.setvar(~mqrobotfakecpu_total~[;] self.roll_total); target.roll_totaldice = self.roll_totaldice;
mqjesterdeck,Internal script for Enemy Jester deck simulation,var availeq = 0; var hand = []; for (eq in self.equipment) if (eq.skillcard == ~~ && (eq.ready # (eq.y > 0 && eq.y < 2160)) && eq.equipalpha > 0.1) {availeq++; eq.size = 2; if (eq.ready && eq.getvar(~mqjesterdeckexistturns~) >= 2) {var already_added = false; if (hand.length > 0) for (card in hand) if (card.name == eq.name) {card.count++; card.name = eq.name; card.eqs.push(eq);} if (!already_added) hand.push({name: eq.name[;] count: 1[;] eqs: [eq]});}} if (hand.length > 0) for (card in hand) if (card.count > 1) {sfx(~jester_discard~); for (eq in card.eqs) {eq.animate(~curse~); var anim = eq.animation[eq.animation.length - 1]; anim.parameter[2] = ~[star] Discarded!~; anim.command[5] = ~~; eq.ready = false; eq.usedthisbattle = true;}} var tempdeck = self.getvar(~mqjesterdecktemp~); for (i in 0...3) if (tempdeck.length >= (i + 1)) self.setvar(~mqjesterdeck~ + (i + 1)[;] tempdeck[i]); else self.setvar(~mqjesterdeck~ + (i + 1)[;] ~~); self.setvar(~mqjesterdeckleft~[;] tempdeck.length); if (availeq < 3 && tempdeck.length > 0) {giveequipment(tempdeck.shift()[;] true[;] false); for (eq in self.equipment) eq.setvar(~mqjesterdeckexistturns~[;] eq.getvar(~mqjesterdeckexistturns~) + 1);} self.setvar(~mqjesterdecktemp~[;] tempdeck);
Headphones,Suppress [silence]1,inflictself(~mqsuppress~); sfx(~_silence~[;] ~~[;] 0.2);
mqsuppress,Internal script for Suppress status effect,if (self.scriptbeforestartturn.indexOf(~/*mqsuppress_script_injected*/~) == -1) {self.scriptbeforestartturn += ~ /*mqsuppress_script_injected*/ if (self.getvar(\~suppress_turn\~) != turn) {removestatusself(WEAKEN[;] getstatusself(\~mqsuppress_all\~) <= 0 ? getstatusself(\~mqsuppress\~) : getstatusself(\~mqsuppress\~)); removestatusself(\~mqsuppress\~[;] ALL); removestatusself(\~mqsuppress_all\~[;] ALL);} self.setvar(\~suppress_turn\~[;] turn);~;}
mqspecialdiceinit,Internal script for highlighting special dice,if (getstatusself(~mqspecialdice~) <= 0) {inflictself(~mqspecialdice~); var actSpecialDice = new motion.actuators.SimpleActuator(null[;] 1[;] null); actSpecialDice.repeat(-1); var funcSpecialDice = new hscript.Parser().parseString(~if (getstatusself(\~mqspecialdice\~) <= 0 # self.hp <= 0 # target.hp <= 0) actSpecialDice._repeat = 0; if (self.dicepool.length > 0) for (mydice in self.dicepool) if (mydice.available() && (mydice.basevalue < 1 # mydice.basevalue > 6)) {mydice.animate(\~\~); var anim = mydice.animation[mydice.animation.length - 1]; anim.addcommand(\~flash\~[;] null[;] 0.1); anim.addcommand(\~shake\~[;] null[;] 0[;] -4); anim.addcommand(\~textparticle\~[;] \~\~ + mydice.basevalue[;] 16777215);}~); var interp = new hscript.Interp(); interp.variables.set(~self~[;] self); interp.variables.set(~target~[;] target); interp.variables.set(~getstatusself~[;] getstatusself); interp.variables.set(~actSpecialDice~[;] actSpecialDice); actSpecialDice.onRepeat(interp.execute[;] [funcSpecialDice]); actSpecialDice.move();}
mqchoicemenu_open,Internal script for custom choice menu,function ceil(n) {var round = n - (n % 1); return round + (round == n ? 0 : 1);} if (self.getvar(~mqchoicemenu_open~) == 0) {self.setvar(~mqchoicemenu_open~[;] 1); if (!self.isplayer) target.setvar(~mqchoicemenu_enemy~[;] self); if (self.equipment.length > 0) for (eq in self.equipment) if (eq.ready && eq.getvar(~mqchoicemenu_moved~) == 0 && eq.getvar(~mqchoicemenu_header~) == 0) {eq.ready = false; eq.setvar(~mqchoicemenu_moved~[;] 1); eq.setvar(~mqchoicemenu_x~[;] eq.x); eq.finalpos = new openfl.geom.Point(eq.x < 3840 / 2 ? -eq.width : 3840 + eq.width[;] eq.y); var actMoveAway = new motion.actuators.SimpleActuator(eq[;] 0.75[;] {x: eq.finalpos.x}); actMoveAway.move();} var optionList = []; var _optionList = self.getvar(~mqchoicemenu_optionlist~); if (_optionList.length == null) _optionList = []; if (_optionList.length > 0) for (option in _optionList) optionList.push(option); if (self.getvar(~mqchoicemenu_shuffle~) == 1) shuffle(optionList); var myOptions = []; var baseOptions = self.getvar(~mqchoicemenu_baseoptions~); if (baseOptions > 0) for (i in 0...baseOptions) if (optionList.length > 0) myOptions.push(optionList.shift()); if (myOptions.length == 0) myOptions.push(~Generic Option@mqchoicemenu~); var c = 0; var rows = ceil(myOptions.length / 3); for (option in myOptions) {var eq = new elements.Equipment(option.big ? ~Generic Option@mqchoicemenu_big~ : ~Generic Option@mqchoicemenu~); eq.displayname = option.name; eq.fulldescription = option.description + (option.overridedescription ? ~~ : eq.fulldescription); eq.script = (option.script != null ? option.script : ~~) + ~ ~ + eq.script; eq.scriptbeforeexecute = eq.scriptbeforeexecute.split(~/*mqchoicemenu_script_start*/~)[0] + ~/*mqchoicemenu_script_start*/~ + (option.script_before_execute != null ? ~ ~ + option.script_before_execute : ~~) + ~ ~ + eq.scriptbeforeexecute.split(~/*mqchoicemenu_script_start*/~)[1]; eq.changecolour(option.colour); eq.setvar(~mqchoicemenu_option~[;] 1); eq.temporary_thisturnonly = true; eq.setvar(~mqchoicemenu_amitheenemy~[;] self.isplayer ? 0 : 1); self.equipment.push(eq); var row = ceil((c + 1) / 3); if (eq != null) {eq.x = 3840 / (row >= rows ? ((myOptions.length - 1) % 3) + 1 : 3) * ((c % 3) + 0.5) - eq.width / 2; eq.y = 2160 / 2 - 2160 * 0.3 + 2160 * 0.6 / rows * (row - 0.5) - eq.height / 2; if (rows >= 3) {eq.height = 330; if (eq.slotpositions.length > 0) for (slotposition in eq.slotpositions) {slotposition.x = eq.width + 30; slotposition.y = 0;} eq.x -= 160; eq.y += 141;} eq.equipalpha = 0; var actFadeIn = new motion.actuators.SimpleActuator(eq[;] 1[;] {equipalpha: 1}); actFadeIn.move();} c++;} var headerExists = false; for (eq in self.equipment) if (eq.getvar(~mqchoicemenu_header~) == 1) headerExists = true; if (!headerExists && self.isplayer) {var header = new elements.Equipment(~Menu Header@mqchoicemenu~); header.temporary_thisturnonly = true; self.equipment.push(header); header.x = 3840 / 2 - header.width / 2; header.y = 100; header.height = 0; header.setvar(~mqchoicemenu_header~[;] 1); var headerText = self.getvar(~mqchoicemenu_headertext~); if (headerText.length == null) headerText = ~~; header.displayname = ~[huge]~ + headerText + ~[]~;}}
mqchoicemenu_dismiss,Internal script for custom choice menu,self.setvar(~mqchoicemenu_open~[;] 0); var _skill = new elements.Skill(~Broken Gadget~); var _script_on_choose = self.getvar(~mqchoicemenu_script_on_choose~); if (_script_on_choose.length == null) _script_on_choose = ~~; _skill.script = _script_on_choose; _skill.execute(self[;] target); for (eq in self.equipment) if (eq.getvar(~mqchoicemenu_header~) == 1) {var headerText = self.getvar(~mqchoicemenu_headertext~); if (headerText.length == null) headerText = ~~; eq.displayname = ~[huge]~ + headerText + ~[]~;} if (self.equipment.length > 0) for (eq in self.equipment) if (eq.ready && eq.getvar(~mqchoicemenu_option~) == 1) {eq.ready = false; var actFadeOut = new motion.actuators.SimpleActuator(eq[;] 0.75[;] {equipalpha: 0}); actFadeOut.move();} if (self.getvar(~mqchoicemenu_extrachoices~) > 0) {new elements.Skill(~mqchoicemenu_open~).execute(self[;] target); self.setvar(~mqchoicemenu_extrachoices~[;] self.getvar(~mqchoicemenu_extrachoices~) - 1);} else {var actMain = new motion.actuators.SimpleActuator(null[;] 0.75[;] null); var mainFunc = new hscript.Parser().parseString(~if (self.equipment.length > 0) for (eq in self.equipment) if (eq.getvar(\~mqchoicemenu_moved\~) == 1) {eq.ready = true; eq.setvar(\~mqchoicemenu_moved\~[;] 0); eq.finalpos = new openfl.geom.Point(eq.getvar(\~mqchoicemenu_x\~)[;] eq.y); var actMoveBack = new motion.actuators.SimpleActuator(eq[;] 0.75[;] {x: eq.finalpos.x}); actMoveBack.move();}~); var interp = new hscript.Interp(); interp.variables.set(~self~[;] self); actMain.onComplete(interp.execute[;] [mainFunc]); actMain.move(); if (self.equipment.length > 0) for (eq in self.equipment) if (eq.getvar(~mqchoicemenu_header~) == 1) {eq.setvar(~mqchoicemenu_header~[;] 0); var actFadeOut = new motion.actuators.SimpleActuator(eq[;] 0.75[;] {equipalpha: 0}); actFadeOut.move();} self.setvar(~mqchoicemenu_shuffle~[;] 0); self.setvar(~mqchoicemenu_script_on_choose~[;] 0);}
mqchoicemenu_fixreequip_begin,Internal script for custom choice menu,self.setvar(~mqchoicemenu_reequip~[;] getstatusself(REEQUIPNEXT)); removestatusself(REEQUIPNEXT);
mqchoicemenu_fixreequip_end,Internal script for custom choice menu,if (self.getvar(~mqchoicemenu_reequip~) > 0) inflictself(REEQUIPNEXT[;] self.getvar(~mqchoicemenu_reequip~)); self.setvar(~mqchoicemenu_reequip~[;] 0);
mqchoicemenu_pickoption,Internal script for custom choice menu,new elements.Skill(~mqchoicemenu_dismiss~).execute(self[;] target); new elements.Skill(~mqchoicemenu_fixreequip_begin~).execute(self[;] target);
mqchoicemenu_tidy,Internal script for custom choice menu,if (self.equipment.length > 0) for (eq in self.equipment) eq.setvar(~mqchoicemenu_moved~[;] 0); self.setvar(~mqchoicemenu_optionlist~[;] 0);
mqfixeqpositions,Internal script for fixing equipment positions,if (self.equipment.length > 0) for (eq in self.equipment) if (eq.ready && (!eq.onceperbattle # !eq.usedthisbattle) && eq.finalpos != null) {var actFixPositions = new motion.actuators.SimpleActuator(eq[;] 0.75[;] {x: eq.finalpos.x[;] y: eq.finalpos.y}); actFixPositions.move();}
mqorbitalcaster_fixpositions,Internal script for Orbital Caster episode,function ceil(n) {var round = n - (n % 1); return round + (round == n ? 0 : 1);} function around(number1[;] number2[;] error) return number1 >= number2 - error && number1 <= number2 + error; var fadeInAnimation = self.getvar(~mqorbitalcaster_fadeinanimation~) == 0; self.setvar(~mqorbitalcaster_fadeinanimation~[;] 1); var enterAnimation = self.getvar(~mqorbitalcaster_enteranimation~) == 0; self.setvar(~mqorbitalcaster_enteranimation~[;] 1); var free_indexes = [1[;] 2[;] 3[;] 4[;] 5[;] 6]; var matching_indexes = [[][;] [][;] [][;] [][;] [][;] [][;] []]; var totalItems = 6; if (self.equipment.length > 0) {for (eq in self.equipment) if (eq.skillcard == ~~ && eq.getvar(~mqorbitalcaster_index~) != 0) {free_indexes.remove(eq.getvar(~mqorbitalcaster_index~)); matching_indexes[eq.getvar(~mqorbitalcaster_index~)].push(eq);} for (matching_index in 1...7) if (matching_indexes[matching_index].length >= 2) {free_indexes.push(matching_index); for (eq in matching_indexes[matching_index]) eq.setvar(~mqorbitalcaster_index~[;] 0);} for (eq in self.equipment) if (eq.skillcard == ~~ && eq.getvar(~mqorbitalcaster_index~) == 0) eq.setvar(~mqorbitalcaster_index~[;] free_indexes.shift());} if (self.equipment.length > 0) for (eq in self.equipment) if (eq.skillcard == ~~) {var angle = ceil((210 + 360 / totalItems * (eq.getvar(~mqorbitalcaster_index~) + self.getvar(~mqorbitalcaster_step~))) % 360); if (angle < 0) angle += 360; eq.setvar(~mqorbitalcaster_angle~[;] angle); if (eq.ready) {if (enterAnimation) {eq.x = 3840 / 2 - eq.width / 2 + 850 * 1.25 * self.getvar(~cos~ + (angle - 90)); eq.y = 2160 / 2 - eq.height / 2 + 650 * 1.25 * self.getvar(~sin~ + (angle - 90));} if (fadeInAnimation) {eq.equipalpha = 0; var actFadeIn = new motion.actuators.SimpleActuator(eq[;] 0.75[;] {equipalpha: 1}); actFadeIn.move();} eq.finalpos = new openfl.geom.Point(3840 / 2 - eq.width / 2 + 850 * self.getvar(~cos~ + angle)[;] 2160 / 2 - eq.height / 2 + 650 * self.getvar(~sin~ + angle));} var positions = [{name: ~top~[;] angles: [270]}[;] {name: ~bottom~[;] angles: [90]}[;] {name: ~topleft~[;] angles: [210]}[;] {name: ~topright~[;] angles: [330]}[;] {name: ~bottomleft~[;] angles: [150]}[;] {name: ~bottomright~[;] angles: [30]}]; for (position in positions) {var inPosition = 0; for (angle2 in position.angles) if (around(angle[;] angle2[;] 5)) inPosition = 1; eq.setvar(~mqorbitalcaster_position_~ + position.name[;] inPosition);}} var skillcard = null; for (eq in self.equipment) if (eq.skillcard == ~mqorbitalcaster~) skillcard = eq; if (skillcard != null && skillcard.ready) {skillcard.finalpos = new openfl.geom.Point(3840 / 2 - skillcard.width / 2[;] 2160 / 2 - skillcard.height / 2);} new elements.Skill(~mqfixeqpositions~).execute(self[;] target);
mqorbitalcaster_spin,Internal script for Orbital Caster episode,var spins = 0; if (getstatusself(~mqorbitalcaster_nostep~) <= 0 && getstatusself(~mqorbitalcaster_nostep_all~) <= 0) {self.setvar(~mqorbitalcaster_step~[;] self.getvar(~mqorbitalcaster_step~) + 1 * (getstatusself(~mqorbitalcaster_reverse~) <= 0 && getstatusself(~mqorbitalcaster_reverse_all~) <= 0 ? 1 : -1) * (getstatusself(~mqorbitalcaster_extrastep~) <= 0 && getstatusself(~mqorbitalcaster_extrastep_all~) <= 0 ? 1 : 2)); self.setvar(~mqorbitalcaster_spinshappened~[;] getstatusself(~mqorbitalcaster_extrastep~) <= 0 && getstatusself(~mqorbitalcaster_extrastep_all~) <= 0 ? 1 : 2); removestatusself(~mqorbitalcaster_extrastep~); removestatusself(~mqorbitalcaster_reverse~);} removestatusself(~mqorbitalcaster_nostep~); new elements.Skill(~mqorbitalcaster_fixpositions~).execute(self[;] target); new elements.Skill(~mqorbitalcaster_step_scripts~).execute(self[;] target);
mqorbitalcaster_step_scripts,Internal script for Orbital Caster episode,var spins = self.getvar(~mqorbitalcaster_spinshappened~); self.setvar(~mqorbitalcaster_spinshappened~[;] 0); if (self.equipment.length > 0) for (eq in self.equipment) if (eq.skillcard == ~~) {var script_on_step = ~~; if (eq.scriptbeforeexecute.indexOf(~/*mqorbitalcaster_on_step:~) != -1) script_on_step = eq.scriptbeforeexecute.split(~/*mqorbitalcaster_on_step:~)[1].substr(0[;] eq.scriptbeforeexecute.split(~/*mqorbitalcaster_on_step:~)[1].indexOf(~*/~)); var skill = new elements.Skill(~Unlimited~); self.setvar(~mqorbitalcaster_e~[;] eq); skill.script = ~var e = self.getvar(\~mqorbitalcaster_e\~); var spins = ~ + spins + ~; ~ + script_on_step; if (eq.ready) skill.execute(self[;] target); self.setvar(~mqorbitalcaster_e~[;] 0);}
One More Spin,Get an extra spin for this turn,self.setvar(~mqorbitalcaster_rotations~[;] self.getvar(~mqorbitalcaster_rotations~) + 1); sfx(~_recycle~);
Two More Spins,Get two extra spins for this turn,self.setvar(~mqorbitalcaster_rotations~[;] self.getvar(~mqorbitalcaster_rotations~) + 2); sfx(~_recycle~);
mqsnapeq,Internal script for activating equipment for free,function min(n1[;] n2) return n1 < n2 ? n1 : n2; var e = self.getvar(~mqsnapeq~); e.shockedsetting = 0; e.positionshockslots(); var slotsFilled = false; if (e.countdown > 0 && e.slots.indexOf(~COUNTDOWN~) == 0) {e.remainingcountdown = 6; givedice(6); e.assigndice(self.dicepool[self.dicepool.length - 1]);} var newdice = []; var total = e.needstotal > 0 ? e.needstotal : 9999; if (e.slots.length > 0) for (slot in e.slots) {var d = 0; switch (slot) {case ~NORMAL~: d = 6; case ~MIN2~: d = 6; case ~MIN3~: d = 6; case ~MIN4~: d = 6; case ~MIN5~: d = 6; case ~MIN6~: d = 6; case ~MAX6~: d = 6; case ~REQUIRE6~: d = 6; case ~EVEN~: d = 6; case ~DOUBLES~: d = 6; case ~MAX5~: d = 5; case ~ODD~: d = 5; case ~REQUIRE5~: d = 5; case ~RANGE25~: d = 5; case ~RANGE35~: d = 5; case ~RANGE45~: d = 5; case ~MAX4~: d = 4; case ~REQUIRE4~: d = 4; case ~RANGE24~: d = 4; case ~RANGE34~: d = 4; case ~MAX3~: d = 3; case ~REQUIRE3~: d = 3; case ~RANGE23~: d = 3; case ~MAX2~: d = 2; case ~REQUIRE2~: d = 2; case ~MAX1~: d = 1; case ~REQUIRE1~: d = 1;} d = min(d[;] total); total -= d; newdice.push(d);} var c = 0; if (newdice.length > 0) {slotsFilled = true; for (d in newdice) {if (d != 0) {givedice([d]); e.assigndice(self.dicepool[self.dicepool.length - 1][;] c);} c++;}} if (slotsFilled && e.countdown <= 0) e.doequipmentaction(self[;] target[;] (self.isplayer ? 1 : -1)[;] e.assigneddice[;] self.getvar(~mqsnapeq_delay~)); e.animate(~flashandshake~); e.animate(~~); var anim = e.animation[e.animation.length - 1]; anim.addcommand(~textparticle~[;] ~Snap!~[;] 16777215);
Jump In,Snap random item,var possibleEquipment = []; for (eq in self.equipment) if (eq.ready && eq.availablethisturn && eq.skillcard == ~~ && eq.slots.length > 0) possibleEquipment.push(eq); if (possibleEquipment.length > 0) {self.setvar(~mqsnapeq~[;] rand(possibleEquipment)); new elements.Skill(~mqsnapeq~).execute(self[;] target); self.setvar(~mqsnapeq~[;] 0);} sfx(~jester_snap~);
mqcustomscript,Internal script for loading custom scripts,var Rules = self.getvar(~Rules~); var scriptData = self.getvar(~mqcustomscript~); var passVariables = scriptData.variables != null && scriptData.variables.length > 0; var loadOnce = scriptData.loadOnce != null && scriptData.loadOnce; var script = ~~; if (!loadOnce # self.getvar(~mqcustomscript_~ + scriptData.file).length == null) {Rules.rulescreen(scriptData.file); script = Rules.rulescreen_text.join(~ ~); self.setvar(~mqcustomscript_~ + scriptData.file[;] script);} else {script = self.getvar(~mqcustomscript_~ + scriptData.file);} if (passVariables) for (variable in scriptData.variables) {self.setvar(~mqcustomscript_variable_~ + variable.name[;] variable.value); script = ~var ~ + variable.name + ~ = self.getvar(\~mqcustomscript_variable_~ + variable.name + ~\~); ~ + script;} var skill = new elements.Skill(~Unlimited~); skill.script = script; skill.execute(self[;] target); Rules.overworldbutton_action = ~~; Rules.rulescreen_text = []; self.setvar(~Rules~[;] 0); self.setvar(~mqcustomscript~[;] 0); if (passVariables) for (variable in scriptData.variables) self.setvar(~mqcustomscript_variable_~ + variable.name[;] 0);
mqloadcsv,Internal script for loading custom CSV files,var Rules = self.getvar(~Rules~); Rules.rulescreen(self.getvar(~mqloadcsv~)); var csvData = Rules.rulescreen_text; var processedData = []; if (csvData.length > 0) {var headers = csvData[0].split(~[;]~); if (headers.length > 0) {for (header in headers) processedData.push({header: header[;] data: []}); var headerLine = csvData.shift(); for (c in 0...headers.length) for (csvLine in csvData) if (csvLine.length > 0 && csvLine != headerLine) {csvLine = csvLine.split(~[;]~); processedData[c].data.push(csvLine[c]);}}} for (processedDataPart in processedData) self.setvar(~mqloadcsv_~ + self.getvar(~mqloadcsv~) + ~_~ + processedDataPart.header[;] processedDataPart.data); self.setvar(~Rules~[;] 0); self.setvar(~mqloadcsv~[;] 0);
mqsilence,Internal script for inflicting Silence status effect (adds support for enemy; Robot and Jester silence),if (!target.isplayer) inflict(~mqenemysilence~); else {if (target.name != ~Robot~ && target.name != ~Jester~) inflict(SILENCE); else if (target.name == ~Robot~) inflict(~mqrobotsilence~); else if (target.name == ~Jester~) inflict(~mqjestersilence~);} if (target.scriptbeforestartturn.indexOf(~/*mqsilence_script_injected*/~) == -1) {target.scriptbeforestartturn += ~ /*mqsilence_script_injected*/ if (getstatusself(\~mqrobotsilence\~) > 0) {self.roll_error = 1;}~; target.scriptonstartturn += ~ if (getstatusself(\~mqenemysilence\~) > 0) {var skillcard = null; if (self.equipment.length > 0) {for (eq in self.equipment) if (skillcard == null # (eq.x >= skillcard.x && eq.skillcard == \~\~)) skillcard = eq; for (eq in self.equipment) if (skillcard == null # (eq.x >= skillcard.x && eq.y >= skillcard.y && eq.skillcard == \~\~)) skillcard = eq;} if (skillcard != null) {skillcard.shockedsetting = 1; skillcard.shockedtext = \~Reduce countdown to 0\~ + \~#\~.substr(0[;] 1) + \~to break silence\~; skillcard.shockedtype = skillcard.shockedtype.COUNTDOWN; skillcard.positionshockslots(); skillcard.shocked_countdown = 6; skillcard.shocked_remainingcountdown = skillcard.shocked_countdown; skillcard.flashtime = 0.1; sfx(\~apply_silence_to_equipment\~);}} if (getstatusself(\~mqrobotsilence\~) > 0) {removestatusself(\~mqrobotsilence\~[;] ALL); self.addstatus(SILENCE[;] 1); self.roll_error = 0; var newdice = []; var total = self.roll_target - 1; for (i in 0...2) {var d = rand([1[;] 2[;] 3[;] 4[;] 5[;] 6]); if (d > total) d = total; total -= d; newdice.push(d);} self.roll_total += self.roll_target - 1 - total; self.roll_barposition = self.roll_total * 100; givedice(newdice);} if (getstatusself(\~mqjestersilence\~) > 0) {removestatusself(\~mqjestersilence\~[;] ALL); self.layout = self.layout.EQUIPMENT; self.setvar(\~mqjestersilence_layout_changed\~[;] 1); var unsilenceEq = new elements.Equipment(\~@mqjestersilence\~); unsilenceEq.equippedby = self; unsilenceEq.x = 2898; unsilenceEq.y = 621; unsilenceEq.flashtime = 0.1; unsilenceEq.skillcard = \~mqjestersilence\~; self.addstatus(SILENCE[;] 1); var actUnsilenceEq = new motion.actuators.SimpleActuator(null[;] 0[;] null); var funcUnsilenceEq = new hscript.Parser().parseString(\~if (getstatusself(\\\~mqtimeruntilendturn\\\~) <= 0) actUnsilenceEq._repeat = 0; if (e.ready && self.equipment.indexOf(e) == -1) self.equipment.push(e); if (e.shockedsetting == 2 && e.getvar(\\\~mqjestersilence_shocked\\\~) != 1) e.setvar(\\\~mqjestersilence_shocked\\\~[;] 1); if (e.getvar(\\\~mqjestersilence_shocked\\\~) == 1 && e.shockedsetting == 0 && e.unshockingtimer <= 0) {self.equipment.remove(e); removestatusself(SILENCE[;] ALL); self.layout = self.layout.DECK; self.setvar(\\\~mqjestersilence_layout_changed\\\~[;] 0); actUnsilenceEq._repeat = 0;} if (self.equipment.length > 0) for (eq in self.equipment) if (eq.cursedimage == 1 && eq.getvar(\\\~mqjestersilence_curse_advance\\\~) != 1) {eq.setvar(\\\~mqjestersilence_curse_advance\\\~[;] 1); Deck.advance();}\~); actUnsilenceEq.repeat(-1); var interp = new hscript.Interp(); interp.variables.set(\~self\~[;] self); interp.variables.set(\~e\~[;] unsilenceEq); interp.variables.set(\~actUnsilenceEq\~[;] actUnsilenceEq); interp.variables.set(\~getstatusself\~[;] getstatusself); interp.variables.set(\~removestatusself\~[;] removestatusself); interp.variables.set(\~SILENCE\~[;] SILENCE); interp.variables.set(\~ALL\~[;] ALL); interp.variables.set(\~Deck\~[;] Deck); actUnsilenceEq.onRepeat(interp.execute[;] [funcUnsilenceEq]); actUnsilenceEq.move(); inflictself(\~mqtimeruntilendturn\~);}~; target.scriptendturn += ~ if (self.getvar(\~mqjestersilence_layout_changed\~) == 1) {self.setvar(\~mqjestersilence_layout_changed\~[;] 0); self.layout = self.layout.DECK;}~; target.scriptaftercombat += ~ if (self.getvar(\~mqjestersilence_layout_changed\~) == 1) {self.setvar(\~mqjestersilence_layout_changed\~[;] 0); self.layout = self.layout.DECK;}~;}
Tape,[silence]Silence enemy,new elements.Skill(~mqsilence~).execute(self[;] target); sfx(~_silence~);
mqcursedbite,Internal script for Cursed Bite status effect,var robotSkillcard = null; if (target.getvar(~mqcursedbite_old_equipment~).length == null) {var oldEquipment = []; if (target.equipment.length > 0) for (eq in target.equipment) {oldEquipment.push(eq); if (eq.skillcard.indexOf(~robot_~) != -1) robotSkillcard = eq;} target.setvar(~mqcursedbite_old_equipment~[;] oldEquipment); target.setvar(~mqcursedbite_old_layout~[;] target.layout);} target.layout = target.layout.EQUIPMENT; target.equipment = []; if (robotSkillcard != null) target.equipment.push(robotSkillcard); if (self.equipment.length > 0) for (eq in self.equipment) if (eq.skillcard == ~~ && target.spaceleft() >= eq.size && !eq.temporary_thisturnonly) giveenemyequipment(eq.name + eq.namemodifier[;] false[;] false); if (target.scriptendturn.indexOf(~/*mqcursedbite_script_injected*/~) == -1) {var scriptRevertEquipment = ~/*mqcursedbite_script_injected*/ if (self.getvar(\~mqcursedbite_old_equipment\~).length != null) {self.equipment = self.getvar(\~mqcursedbite_old_equipment\~); self.setvar(\~mqcursedbite_old_equipment\~[;] 0); self.layout = self.getvar(\~mqcursedbite_old_layout\~); self.setvar(\~mqcursedbite_old_layout\~[;] 0);} removestatusself(\~mqcursedbite\~);~; target.scriptendturn += ~ ~ + scriptRevertEquipment; target.scriptaftercombat += ~ ~ + scriptRevertEquipment;}
mqinsanity,Internal script for Insanity status effect,if (target.scriptonstartturn.indexOf(~/*mqinsanity_script_injected*/~) == -1) {target.scriptonstartturn += ~ /*mqinsanity_script_injected*/ if (getstatusself(\~mqinsanity\~) > 0) {var myEquipment = []; if (self.equipment.length > 0) for (eq in self.equipment) if (eq.availablethisturn && eq.ready && eq.skillcard == \~\~) myEquipment.push(eq); shuffle(myEquipment); var insanityEquipment = self.getvar(\~mqinsanity_equipment\~); if (insanityEquipment.length == null) insanityEquipment = []; for (insanityCount in 0...getstatusself(\~mqinsanity\~)) if (myEquipment.length > 0) {var eq = myEquipment.pop(); var eqData = {eq: eq[;] displayname: eq.displayname[;] fulldescription: eq.fulldescription[;] script: eq.script[;] castdirection: eq.castdirection[;] scriptbeforeexecute: eq.scriptbeforeexecute}; insanityEquipment.push(eqData); var vowelsString = \~aeiou\~; var consonantsString = \~bcdfghjklmnpqrstvwxyz\~; var vowels = []; var consonants = []; for (l in 0...vowelsString.length) vowels.push(vowelsString.substr(l[;] 1)); for (l in 0...consonantsString.length) consonants.push(consonantsString.substr(l[;] 1)); eq.displayname = \~\~; for (l in 0...eqData.displayname.length) {var addLetter = rand([rand(vowels)[;] rand(consonants)]); if (l == 0 # eqData.displayname.substr(l - 1[;] 1) == \~ \~) addLetter = rand([rand(vowels)[;] rand(consonants)]).toUpperCase(); if (l > 0 && vowels.indexOf(eqData.displayname.substr(l - 1[;] 1)) != -1) addLetter = rand(chance(90) ? consonants : vowels); if (l > 0 && consonants.indexOf(eqData.displayname.substr(l - 1[;] 1)) != -1) addLetter = rand(chance(30) ? consonants : vowels); if (eqData.displayname.substr(l[;] 1) == \~ \~) addLetter = \~ \~; eq.displayname += addLetter;} eq.fulldescription = \~\~; var baseDescription = eqData.fulldescription; while (baseDescription.indexOf(\~[\~) != -1 && baseDescription.indexOf(\~]\~) != -1) {var tagStart = baseDescription.indexOf(\~[\~); var tagEnd = baseDescription.indexOf(\~]\~); baseDescription = baseDescription.substr(0[;] tagStart) + \~*\~ + baseDescription.substr(tagEnd + 1);} while (baseDescription.indexOf(\~<\~) != -1 && baseDescription.indexOf(\~>\~) != -1) {var tagStart = baseDescription.indexOf(\~<\~); var tagEnd = baseDescription.indexOf(\~>\~); baseDescription = baseDescription.substr(0[;] tagStart) + \~*\~ + baseDescription.substr(tagEnd + 1);} for (l in 0...baseDescription.length) {var addLetter = rand([rand(vowels)[;] rand(consonants)]); if (l == 0 # (baseDescription.substr(l - 1[;] 1) == \~ \~ && chance(20))) addLetter = rand([rand(vowels)[;] rand(consonants)]).toUpperCase(); if (l > 0 && vowels.indexOf(baseDescription.substr(l - 1[;] 1)) != -1) addLetter = rand(chance(90) ? consonants : vowels); if (l > 0 && consonants.indexOf(baseDescription.substr(l - 1[;] 1)) != -1) addLetter = rand(chance(30) ? consonants : vowels); if (baseDescription.substr(l[;] 1) == \~ \~) addLetter = \~ \~; if (baseDescription.substr(l[;] 1) == \~*\~) addLetter = \~*\~; if (baseDescription.substr(l[;] 1) == \~#\~.substr(0[;] 1)) addLetter = \~#\~.substr(0[;] 1); eq.fulldescription += addLetter;} while (eq.fulldescription.indexOf(\~*\~) != -1) eq.fulldescription = new EReg(\~\\\\*\~[;] \~\~).replace(eq.fulldescription[;] rand([\~[\~ + rand([\~sword\~[;] \~fire\~[;] \~ice\~[;] \~shock\~[;] \~poison\~[;] \~weaken\~[;] \~lock\~[;] \~dodge\~[;] \~curse\~[;] \~vanish\~[;] \~reduce\~[;] \~shield\~[;] \~fury\~[;] \~star\~[;] \~blind\~[;] \~red\~[;] \~blue\~[;] \~yellow\~[;] \~gray\~]) + \~]\~[;] \~<\~ + rand([\~d6\~[;] \~double\~[;] \~triple\~[;] \~quadruple\~[;] \~quintuple\~[;] \~sextuple\~]) + \~>\~])); eq.scriptrunner = null; var copyEq = new elements.Equipment(rand(getequipmentlist())); self.setvar(\~mqinsanity_script_\~ + eq.displayname[;] copyEq.script); var switchTargets = chance(50); eq.script = \~if (!simulation) {var skill = new elements.Skill(\\\~Unlimited\\\~); skill.script = \\\~var d = \\\~ + d + \\\~; var e = null; if (self.equipment.length > 0) for (eq in self.equipment) if (eq.displayname == \\\\\\\~\~ + eq.displayname + \~\\\\\\\~) e = eq; if (target.equipment.length > 0) for (eq in target.equipment) if (eq.displayname == \\\\\\\~\~ + eq.displayname + \~\\\\\\\~) e = eq; var actualdice = []; if (e != null) actualdice = e.assigneddice; \\\~ + self.getvar(\\\~mqinsanity_script_\~ + eq.displayname + \~\\\~); skill.execute(\~ + (switchTargets ? \~target[;] self\~ : \~self[;] target\~) + \~);} else bonus(rand([100[;] d * 100]));\~; eq.scriptbeforeexecute = \~delay(1.0);\~; eq.castdirection = copyEq.castdirection * (switchTargets ? -1 : 1); var eqCurseAnimation = new elements.Equipment(eq.name); eqCurseAnimation.x = eq.x; eqCurseAnimation.y = eq.y; eqCurseAnimation.size = eq.size; eqCurseAnimation.width = eq.width; eqCurseAnimation.height = eq.height; eqCurseAnimation.temporary_thisturnonly = true; eqCurseAnimation.ready = false; self.equipment.push(eqCurseAnimation); eqCurseAnimation.animate(\~curse\~); var anim = eqCurseAnimation.animation[eqCurseAnimation.animation.length - 1]; anim.parameter[2] = \~[jinx] Insanity!\~;} self.setvar(\~mqinsanity_equipment\~[;] insanityEquipment); sfx(\~_thinghappens\~);}~; var scriptRevertEquipment = ~var insanityEquipment = self.getvar(\~mqinsanity_equipment\~); if (insanityEquipment.length != null) {if (insanityEquipment.length > 0) for (eqData in insanityEquipment) {var eq = eqData.eq; eq.displayname = eqData.displayname; eq.fulldescription = eqData.fulldescription; eq.scriptrunner = null; eq.script = eqData.script; eq.scriptbeforeexecute = eqData.scriptbeforeexecute; eq.castdirection = eqData.castdirection;} self.setvar(\~mqinsanity_equipment\~[;] 0);}~; target.scriptendturn += ~ ~ + scriptRevertEquipment; target.scriptaftercombat += ~ ~ + scriptRevertEquipment;}
mqencase,Internal script for Encase status effect,if (target.scriptonstartturn.indexOf(~/*mqencase_script_injected*/~) == -1) {target.scriptonstartturn += ~ /*mqencase_script_injected*/ if (getstatusself(\~mqencase\~) > 0 # getstatusself(\~mqencase_all\~) > 0) {var encaseEq = []; if (self.equipment.length > 0) for (eq in self.equipment) if (eq.skillcard == \~\~ && eq.availablenextturn) encaseEq.push(eq); shuffle(encaseEq); encaseEq.sort(function (eq1[;] eq2) return eq1.script.indexOf(\~/*mqencaseattract*/\~) != -1 ? -1 : 1); var popCount = encaseEq.length - getstatusself(\~mqencase\~); if (getstatusself(\~mqencase_all\~) > 0) popCount = 0; if (popCount > 0) for (i in 0...popCount) encaseEq.pop(); if (encaseEq.length > 0) for (eq in encaseEq) {var name = eq.name + eq.namemodifier; var displayname = eq.displayname; var x = eq.x; var y = eq.y; eq.create(\~Rule Crystal@\~ + (eq.size == 1 ? \~small\~ : \~big\~)); eq.resetslots(); eq.skillcard = \~crystalina_locked_\~ + name; eq.displayname = displayname; eq.x = x; eq.y = y; eq.animate(\~\~); eq.animation[eq.animation.length - 1].addcommand(\~textparticle\~[;] \~[mana] Encase!\~[;] 16777215); eq.animate(\~flashandshake\~);} sfx(\~_mana\~);}~; target.scriptaftercombat = ~if (self.equipment.length > 0) for (eq in self.equipment) if (eq.name.indexOf(\~Rule Crystal\~) != -1) eq.create(eq.skillcard.split(\~crystalina_locked_\~)[1][;] eq.upgraded # eq.originallyupgraded);~;}
Quartz Cage,Encase [mana]all (once),Gadget.changegadget(self[;] ~Crystal Trap~[;] ~Broken Gadget~); inflict(~mqencase_all~); new elements.Skill(~mqencase~).execute(self[;] target); sfx(~_mana~);
Crystal Trap,Encase [mana]all,inflict(~mqencase_all~); new elements.Skill(~mqencase~).execute(self[;] target); sfx(~_mana~);
mqsubzero,Internal script for Subzero status effect,if (target.scriptbeforestartturn.indexOf(~/*mqsubzero_script_injected*/~) == -1) {target.scriptbeforestartturn += ~ /*mqsubzero_script_injected*/ if (getstatusself(\~mqsubzero\~) > 0) {inflictself(\~mqtimeruntilendturn\~); var actSubzero = new motion.actuators.SimpleActuator(null[;] 0[;] null); actSubzero.repeat(-1); var funcSubzero = new hscript.Parser().parseString(\~if (getstatusself(\\\~mqtimeruntilendturn\\\~) <= 0) actSubzero._repeat = 0; var alldice = []; if (self.dicepool.length > 0) for (mydice in self.dicepool) if (mydice.available()) alldice.push(mydice); if (alldice.length > 0) for (mydice in alldice) {if (mydice.animation.length > 0) for (anim in mydice.animation) {if (anim.command[5] == \\\~reducestat\\\~ && anim.command[6] == \\\~unlock\\\~) {for (i in 0...anim.command.length) anim.command[i] = \\\~\\\~; mydice.animate(\\\~\\\~[;] 0); var newanim = mydice.animation[mydice.animation.length - 1]; newanim.currenttime = anim.currenttime; newanim.applytodice(mydice); newanim.addcommand(\\\~soundevent\\\~[;] \\\~_dicefreeze\\\~); newanim.addcommand(\\\~overlaytileonce\\\~[;] \\\~ice\\\~[;] -150[;] -126[;] 0.01[;] 1); newanim.addcommand(\\\~applyvariable\\\~[;] \\\~lock\\\~); newanim.addcommand(\\\~reducestat\\\~[;] \\\~ice\\\~);}}}\~); var interp = new hscript.Interp(); interp.variables.set(\~self\~[;] self); interp.variables.set(\~getstatusself\~[;] getstatusself); interp.variables.set(\~actSubzero\~[;] actSubzero); actSubzero.onRepeat(interp.execute[;] [funcSubzero]); actSubzero.move();}~;}
Syringe Gun,Inflict [poison]1 poison,inflict(POISON); sfx(~_poison~);
Spray Paint,Blind [blind]5 dice,inflict(BLIND[;] 5); sfx(~_blind~);
Royal Staff,Do [sword]3[;] weaken [weaken]2,attack(3); sfxdamage(target[;] 3); inflict(WEAKEN[;] 2); sfx(~_weaken~);
Symmetry,Roll an even dice,givedice(rand([2[;] 4[;] 6]));
Petals,Roll an odd dice,givedice(rand([1[;] 3[;] 5]));
Purification,[curse]Uncurse self,removestatusself(CURSE[;] ALL); sfx(~_survive~);
mqfatigue,Internal script for Fatigue status effect,if (target.scriptbeforestartturn.indexOf(~/*mqfatigue_script_injected*/~) == -1) {target.scriptbeforestartturn += ~ /*mqfatigue_script_injected*/ if (getstatusself(\~mqfatigue\~) > 0) {var weakenData = []; if (self.equipment.length > 0) for (eq in self.equipment) {weakenData.push({eq: eq[;] weakentype: eq.weakentype}); eq.weakentype = \~noeffect\~;} self.setvar(\~mqfatigue\~[;] weakenData);}~; var scriptRevertEquipment = ~if (self.getvar(\~mqfatigue\~).length != null) {for (weakenData in self.getvar(\~mqfatigue\~)) weakenData.eq.weakentype = weakenData.weakentype; self.setvar(\~mqfatigue\~[;] 0);}~; target.scriptendturn += ~ ~ + scriptRevertEquipment; target.scriptaftercombat += ~ ~ + scriptRevertEquipment;}
Focus,All dice become 6,if (self.dicepool.length > 0) for (mydice in self.dicepool) if (mydice.available()) {mydice.animate(~~); var anim = mydice.animation[mydice.animation.length - 1]; anim.addcommand(~flash~[;] null[;] 0.1); anim.addcommand(~shake~[;] null[;] 0[;] -4); mydice.basevalue = 6;} sfx(~useitem~);
Reroll,Reroll unused dice,if (self.dicepool.length > 0) for (mydice in self.dicepool) if (mydice.available()) {mydice.animate(~~); var anim = mydice.animation[mydice.animation.length - 1]; anim.addcommand(~flash~[;] null[;] 0.1); anim.addcommand(~shake~[;] null[;] 0[;] -4); mydice.basevalue = rand([1[;] 2[;] 3[;] 4[;] 5[;] 6]);} sfx(~useitem~);
Meganudge,[]-1 to all dice,if (self.dicepool.length > 0) for (mydice in self.dicepool) if (mydice.available()) {mydice.animate(~~); var anim = mydice.animation[mydice.animation.length - 1]; anim.addcommand(~flash~[;] null[;] 0.1); anim.addcommand(~shake~[;] null[;] 0[;] -4); if (mydice.basevalue > 1) mydice.basevalue--;} sfx(~useitem~);
Megabump,[]+1 to all dice,if (self.dicepool.length > 0) for (mydice in self.dicepool) if (mydice.available()) {mydice.animate(~~); var anim = mydice.animation[mydice.animation.length - 1]; anim.addcommand(~flash~[;] null[;] 0.1); anim.addcommand(~shake~[;] null[;] 0[;] -4); if (mydice.basevalue < 6) mydice.basevalue++; else givedice(1);} sfx(~useitem~);
Battle Wrench,Combine all dice,var dicesum = 0; var removeDice = []; if (self.dicepool.length > 0) for (mydice in self.dicepool) if (mydice.available()) {dicesum += mydice.basevalue; removeDice.push(mydice);} if (removeDice.length > 0) for (mydice in removeDice) self.dicepool.remove(mydice); if (dicesum > 0) givedice(dicesum); sfx(~useitem~);
Steal,Borrow equipment,if (self.getvar(~mqsteal_turn~) != turn) {var space = 8; if (self.equipment.length > 0) for (eq in self.equipment) if (eq.ready) space -= eq.size; if (space < 2) {var allEquipment = []; if (self.equipment.length > 0) for (eq in self.equipment) if (eq.skillcard == ~~ && eq.ready) allEquipment.push(eq); shuffle(allEquipment); var removeSize = 0; if (allEquipment.length > 0) for (eq in allEquipment) {eq.animate(CURSE[;] 0.2 * removeSize); eq.ready = false; removeSize += eq.size; if (removeSize >= 2) break;}} giveequipment(rand(getequipmentlist(target))); new elements.Skill(~mqfixeqpositions~).execute(self[;] target); self.setvar(~mqsteal_turn~[;] turn); var actDelayedFunction = new motion.actuators.SimpleActuator(null[;] 0.1[;] null); actDelayedFunction.onComplete(self.setvar[;] [~mqsteal_turn~[;] 0]); actDelayedFunction.move();}
Magic Lockpick,Split a random dice,var dicelist = []; if (self.dicepool.length > 0) for (mydice in self.dicepool) if (mydice.available()) dicelist.push(mydice); if (dicelist.length > 0) {var mydice = rand(dicelist); self.dicepool.remove(mydice); givedice(split(mydice.basevalue));} sfx(~useitem~);
Unfocused,Set all dice to the same random value,var randvalue = rand([1[;] 2[;] 3[;] 4[;] 5[;] 6]); if (self.dicepool.length > 0) for (mydice in self.dicepool) if (mydice.available()) {mydice.animate(~~); var anim = mydice.animation[mydice.animation.length - 1]; anim.addcommand(~flash~[;] null[;] 0.1); anim.addcommand(~shake~[;] null[;] 0[;] -4); mydice.basevalue = randvalue;} sfx(~useitem~);
Megaflip,Flip all dice upside down,if (self.dicepool.length > 0) for (mydice in self.dicepool) if (mydice.available()) {mydice.animate(~~); var anim = mydice.animation[mydice.animation.length - 1]; anim.addcommand(~flash~[;] null[;] 0.1); anim.addcommand(~shake~[;] null[;] 0[;] -4); mydice.basevalue = 7 - mydice.basevalue;} sfx(~useitem~);
Random Roll,Reroll a random dice,var dicelist = []; if (self.dicepool.length > 0) for (mydice in self.dicepool) if (mydice.available()) dicelist.push(mydice); if (dicelist.length > 0) {var mydice = rand(dicelist); mydice.animate(~~); var anim = mydice.animation[mydice.animation.length - 1]; anim.addcommand(~flash~[;] null[;] 0.1); anim.addcommand(~shake~[;] null[;] 0[;] -4); mydice.basevalue = rand([1[;] 2[;] 3[;] 4[;] 5[;] 6]);} sfx(~useitem~);
Magic Spanner,Combine random dice,var maxvalue = 6; for (i in 0...2) {var dicelist = []; if (self.dicepool.length > 0) for (mydice in self.dicepool) if (mydice.available() && mydice.basevalue < maxvalue) dicelist.push(mydice); if (dicelist.length > 0) {var mydice1 = dicelist.pop(); var mydice2 = dicelist.pop(); givedice(mydice1.basevalue + mydice2.basevalue); self.dicepool.remove(mydice1); self.dicepool.remove(mydice2); break;} else maxvalue = 1000000;} sfx(~useitem~);
Snap!,Matchs are used for free,self.setvar(~mqjesterdeck_snapstyle~[;] ~cards~);
Autoroll,Jackpot guaranteed,self.setvar(~mqrobotfakecpu_guaranteedjackpot~[;] 1);
Possessive Pronoun,You really shouldn't see this.,
